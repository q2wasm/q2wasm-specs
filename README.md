# Quake II WASM
This is a repo designed to educate and explain the goal of this project, as well as how to contribute and create things based on this specification.

# What Is WASM?
WASM is short for WebAssembly, a fairly new technology which has been making the rounds in web circles. It's goal is to provide an extremely simple, safe and effective format for bytecode, primarily aimed at web development. You can read more about WebAssembly here: https://github.com/WebAssembly/design

It may seem confusing to link a web technology to Quake II, as this project has nothing to do with the web. The interesting component of WebAssembly here is the assembly part. There is a lot of existing tooling to both create and consume WebAssembly, and even as an interpreted language, it is fairly fast. One of the main things that drew us to the format is that existing C/C++ code can be compiled down to WebAssembly (via Clang/LLVM 11+). This means that old mods that were written over 20 years ago can be re-compiled to WebAssembly and "just work" on an engine that accepts the new specification. The format is also platform and architecture agnostic: whether you're running a legacy Win32 engine from 1997 or, perhaps, a newer engine re-compiled for x86_64, or maybe even trying to play Quake II portably on an ARM-based platform, the exact same WebAssembly game mod binary will work everywhere!

# The Problem
Quake II modding moving to native compilation caused a lot of ire at the time it was announced, and while at the time it wasn't considered (John Carmack considered it a non-issue since he expected mod authors to release their sources; unfortunately, a lot of authors never considered releasing their sources), new architectures beyond x86 (and mods that have only ever been compiled for Windows x86) create a giant hole in the history of Quake II modding. A lot of people cannot experience these mods, and in some cases these mods were written for such an old dialect of C or for extremely outdated libraries that recompiling them in the now is a hassle.

Developing new mods for Quake II is also a huge cause of shot-foot syndrome. Where does one even start? How does one consider other platforms? It's a problem with no real good solution *other* than developing a new solution to make this process painless, which is what this specification hopes to solve and cause adoption for.

# The Solution
On the archiving front, work has already begun to secure the future of the past of Quake II modding: at https://github.com/Paril/quake2-source-archive, you can browse legacy source code and even re-compile some of them already to WebAssembly binary. The goal of that project is to recompile old sources through a wrapper that will enable them to be loaded on existing engines, as well as newer engines that may implement the q2wasm specification. The wrapper is very early, and currently compiles a native gamex86.dll which can load WebAssembly mods and execute them. This can be viewed here: https://github.com/q2wasm/quake2-wasm

It's considered a proof of concept, and does not implement any of the additional specification that I'm looking to standardize across Quake II engines going forward. In the future, this DLL will be unnecessary to actually execute these mods, and instead older mods will only need to be compiled with a small wrapper that handles the translation from the old native mod interface to the new one.

There will still be a DLL wrapper, but that will solely be to support engines that have not yet implemented the q2wasm specification. The wrapper will allow these engines to load `game.wasm` binaries.

# Specification Goals
The specifications for a q2wasm-supported engine are currently being written. Since we have the *opportunity* to standardize a new API, we also want to reduce friction for engine maintainers. The specifications are being developed with these key points in mind:
* Extensibility: allowing the `game.wasm` binaries to support existing game API modifications that exist in the wild, without requiring major changes or friction on the engine end. Currently, this grouping only includes vanilla and KMQuake2 flavors, since those are the only two real major APIs that are still in use. Going forward, the idea is to enable the WASMs to communicate effectively to the engine as to what is where, and what the engine and/or game needs to be able to properly execute the game code. This also includes a "capability query" interface that both the engine *and* game code implement, and will allow both ends to optionally communicate blocks of data between each other about capabilities it may implement. While q2wasm itself won't use any of these capabilities, other engines can easily extend the game binary by giving it more imports via this system, and game binaries can provide more exports to the engine that it may use.
* Simplicity: existing engines out there are essentially stable and finalized; it would be hard for us to convince engine authors to merge a large swath of changes to support this. In addition, it is paramount that engine authors *do* implement the bare minimum MVP in order for the project to succeed at all. As a result, the MVP for implementation is designed to be *as simple as possible* to implement into existing Quake II engines. That means:
  * No API *changes*! The existing game API must work with no changes. We can't simply take this opportunity to completely erase and re-write the game imports or exports, even if that would benefit creators going forward.
  * Minimal API *additions*. To properly support the **Extensibility** point, there will be *at least* one new import and one new export. These will be the entry points required to support the extensibility concept. Ideally, these will only need to be stubs for the MVP, but we'll get to that point soon.
  * MVP Pull Requests: To take the pressure off of engine authors, we'll be aiming to provide patches, submitted as pull requests, to the major engines out there to support the new system. We will also listen to the feedback of said authors, and address any concerns they may have. Issues should be opened on this repo about the specification.

# The Specification
TODO
